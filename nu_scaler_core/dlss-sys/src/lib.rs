/*!
 * FFI bindings to the NVIDIA DLSS SDK
 * 
 * This crate provides both high-level safe Rust wrappers and low-level raw FFI 
 * bindings to NVIDIA's DLSS (Deep Learning Super Sampling) technology.
 * 
 * The bindings allow for image upscaling using NVIDIA's AI-based upscaling technology
 * to achieve better rendering performance with minimal loss in visual quality.
 */
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused)]

use std::ffi::{c_void, CStr, CString};
use std::path::Path;
use std::ptr;
use std::sync::Once;
use thiserror::Error;

/// Re-exports for convenience
pub use libc::{c_char, c_int, c_uint, size_t};

/// Low-level bindings generated by bindgen
#[cfg(feature = "bindgen")]
mod bindings {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

/// Manually defined bindings when bindgen is not used
#[cfg(not(feature = "bindgen"))]
mod bindings {
    use super::*;
    
    // Reuse the types from the stub implementation
    pub type NVSDK_NGX_Result = u32;
    pub type NVSDK_NGX_Handle_t = *mut c_void;
    pub type NVSDK_NGX_Parameter_t = *mut c_void;
    
    pub const NVSDK_NGX_Result_Success: NVSDK_NGX_Result = 0x1;
    pub const NVSDK_NGX_Result_Fail: NVSDK_NGX_Result = 0x0;
    
    // Feature Types
    pub const NVSDK_NGX_Feature_SuperSampling: u32 = 0;
    pub const NVSDK_NGX_Feature_DLSS: u32 = NVSDK_NGX_Feature_SuperSampling;
    
    // Quality Settings
    pub const NVSDK_NGX_DLSS_QualitySetting_MaxPerformance: u32 = 0;
    pub const NVSDK_NGX_DLSS_QualitySetting_Balanced: u32 = 1;
    pub const NVSDK_NGX_DLSS_QualitySetting_MaxQuality: u32 = 2;
    pub const NVSDK_NGX_DLSS_QualitySetting_Ultra_Performance: u32 = 3;
    pub const NVSDK_NGX_DLSS_QualitySetting_Ultra_Quality: u32 = 4;
    
    extern "C" {
        // Core NGX functions
        pub fn NVSDK_NGX_Init(
            InApplicationId: *const c_char,
            InApplicationDataPath: *const c_char,
            InDevice: *mut c_void,
        ) -> NVSDK_NGX_Result;
        
        pub fn NVSDK_NGX_Shutdown() -> NVSDK_NGX_Result;
        
        pub fn NVSDK_NGX_GetScratchBufferSize(
            InFeatureId: u32,
            InParameters: NVSDK_NGX_Parameter_t,
            OutSizeInBytes: *mut size_t,
        ) -> NVSDK_NGX_Result;
        
        pub fn NVSDK_NGX_CreateFeature(
            InCmdList: *mut c_void,
            InFeatureId: u32,
            InParameters: NVSDK_NGX_Parameter_t,
            OutHandle: *mut NVSDK_NGX_Handle_t,
        ) -> NVSDK_NGX_Result;
        
        pub fn NVSDK_NGX_Release(InHandle: NVSDK_NGX_Handle_t) -> NVSDK_NGX_Result;
        
        pub fn NVSDK_NGX_EvaluateFeature(
            InCmdList: *mut c_void,
            InHandle: NVSDK_NGX_Handle_t,
            InParameters: NVSDK_NGX_Parameter_t,
        ) -> NVSDK_NGX_Result;
        
        pub fn NVSDK_NGX_AllocateParameters(OutParameters: *mut NVSDK_NGX_Parameter_t) -> NVSDK_NGX_Result;
        
        pub fn NVSDK_NGX_DestroyParameters(InParameters: NVSDK_NGX_Parameter_t) -> NVSDK_NGX_Result;
        
        // DLSS specific functions
        pub fn NVSDK_NGX_DLSS_GetOptimalSettings(
            InUserSelectedWidth: u32,
            InUserSelectedHeight: u32,
            InQualitySetting: u32,
            OutRenderOptimalWidth: *mut u32,
            OutRenderOptimalHeight: *mut u32,
            OutMaxRenderWidth: *mut u32,
            OutMaxRenderHeight: *mut u32,
            OutMinRenderWidth: *mut u32,
            OutMinRenderHeight: *mut u32,
        ) -> NVSDK_NGX_Result;
        
        pub fn NVSDK_NGX_DLSS_GetCapability(
            InDevice: *mut c_void,
            OutSupportedQualitySettings: *mut u32,
            OutNumSupportedQualitySettings: *mut u32,
        ) -> NVSDK_NGX_Result;
        
        // Parameter functions
        pub fn NVSDK_NGX_Parameter_SetI(
            InParameters: NVSDK_NGX_Parameter_t,
            InType: u32,
            InValue: u32,
        ) -> NVSDK_NGX_Result;
        
        pub fn NVSDK_NGX_Parameter_SetF(
            InParameters: NVSDK_NGX_Parameter_t,
            InType: u32,
            InValue: f32,
        ) -> NVSDK_NGX_Result;
        
        pub fn NVSDK_NGX_Parameter_SetVoidPointer(
            InParameters: NVSDK_NGX_Parameter_t,
            InType: u32,
            InValue: *mut c_void,
        ) -> NVSDK_NGX_Result;
    }
}

/// Errors that can occur when using the DLSS SDK
#[derive(Error, Debug)]
pub enum DlssError {
    #[error("DLSS SDK initialization failed")]
    InitializationFailed,
    
    #[error("DLSS feature creation failed")]
    FeatureCreationFailed,
    
    #[error("DLSS evaluation failed")]
    EvaluationFailed,
    
    #[error("DLSS feature not supported")]
    FeatureNotSupported,
    
    #[error("Parameters allocation failed")]
    ParametersAllocationFailed,
    
    #[error("Invalid parameter")]
    InvalidParameter,
    
    #[error("DLSS SDK not initialized")]
    NotInitialized,
    
    #[error("Invalid device provided")]
    InvalidDevice,
    
    #[error("Invalid dimensions: {0}")]
    InvalidDimensions(String),
    
    #[error("Unknown error: {0}")]
    Unknown(u32),
}

/// Result type for DLSS operations
pub type Result<T> = std::result::Result<T, DlssError>;

/// Convert raw NVSDK_NGX_Result to Rust Result
fn from_ngx_result(result: bindings::NVSDK_NGX_Result) -> Result<()> {
    match result {
        bindings::NVSDK_NGX_Result_Success => Ok(()),
        0xBEEF0001 => Err(DlssError::FeatureNotSupported),
        0xBEEF0002 => Err(DlssError::NotInitialized),
        0xBEEF0003 => Err(DlssError::InvalidParameter),
        0xBEEF0004 => Err(DlssError::EvaluationFailed),
        _ => Err(DlssError::Unknown(result)),
    }
}

/// DLSS Quality settings
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum DlssQuality {
    UltraPerformance,
    MaxPerformance,
    Balanced,
    MaxQuality,
    UltraQuality,
}

impl DlssQuality {
    /// Convert to raw DLSS SDK quality setting
    pub fn to_raw(&self) -> u32 {
        match self {
            DlssQuality::UltraPerformance => bindings::NVSDK_NGX_DLSS_QualitySetting_Ultra_Performance,
            DlssQuality::MaxPerformance => bindings::NVSDK_NGX_DLSS_QualitySetting_MaxPerformance,
            DlssQuality::Balanced => bindings::NVSDK_NGX_DLSS_QualitySetting_Balanced,
            DlssQuality::MaxQuality => bindings::NVSDK_NGX_DLSS_QualitySetting_MaxQuality,
            DlssQuality::UltraQuality => bindings::NVSDK_NGX_DLSS_QualitySetting_Ultra_Quality,
        }
    }
    
    /// Get approximate scale factor for this quality setting
    pub fn scale_factor(&self) -> f32 {
        match self {
            DlssQuality::UltraPerformance => 0.33,
            DlssQuality::MaxPerformance => 0.5,
            DlssQuality::Balanced => 0.58,
            DlssQuality::MaxQuality => 0.67,
            DlssQuality::UltraQuality => 0.77,
        }
    }
}

/// Handle to the DLSS SDK initialization state
pub struct DlssInstance {
    initialized: bool,
}

impl DlssInstance {
    /// Initialize the DLSS SDK
    pub fn new(app_id: &str, data_path: &str, device: *mut c_void) -> Result<Self> {
        static INIT_ONCE: Once = Once::new();
        let mut instance = DlssInstance { initialized: false };
        
        let c_app_id = CString::new(app_id).unwrap();
        let c_data_path = CString::new(data_path).unwrap();
        
        // Only allow initialization once
        let mut result = bindings::NVSDK_NGX_Result_Fail;
        INIT_ONCE.call_once(|| {
            unsafe {
                result = bindings::NVSDK_NGX_Init(
                    c_app_id.as_ptr(),
                    c_data_path.as_ptr(),
                    device,
                );
            }
        });
        
        if result != bindings::NVSDK_NGX_Result_Success {
            return Err(DlssError::InitializationFailed);
        }
        
        instance.initialized = true;
        Ok(instance)
    }
    
    /// Check if DLSS is supported on the current system
    pub fn is_supported(&self, device: *mut c_void) -> bool {
        if !self.initialized {
            return false;
        }
        
        let mut num_qualities = 0;
        unsafe {
            let result = bindings::NVSDK_NGX_DLSS_GetCapability(
                device,
                ptr::null_mut(),
                &mut num_qualities,
            );
            
            result == bindings::NVSDK_NGX_Result_Success && num_qualities > 0
        }
    }
    
    /// Get supported DLSS quality settings
    pub fn get_supported_qualities(&self, device: *mut c_void) -> Result<Vec<DlssQuality>> {
        if !self.initialized {
            return Err(DlssError::NotInitialized);
        }
        
        let mut num_qualities = 0;
        unsafe {
            let result = bindings::NVSDK_NGX_DLSS_GetCapability(
                device,
                ptr::null_mut(),
                &mut num_qualities,
            );
            
            if result != bindings::NVSDK_NGX_Result_Success {
                return Err(DlssError::FeatureNotSupported);
            }
            
            let mut qualities = vec![0u32; num_qualities as usize];
            
            let result = bindings::NVSDK_NGX_DLSS_GetCapability(
                device,
                qualities.as_mut_ptr(),
                &mut num_qualities,
            );
            
            if result != bindings::NVSDK_NGX_Result_Success {
                return Err(DlssError::FeatureNotSupported);
            }
            
            Ok(qualities.into_iter().map(|q| match q {
                bindings::NVSDK_NGX_DLSS_QualitySetting_Ultra_Performance => DlssQuality::UltraPerformance,
                bindings::NVSDK_NGX_DLSS_QualitySetting_MaxPerformance => DlssQuality::MaxPerformance,
                bindings::NVSDK_NGX_DLSS_QualitySetting_Balanced => DlssQuality::Balanced,
                bindings::NVSDK_NGX_DLSS_QualitySetting_MaxQuality => DlssQuality::MaxQuality,
                bindings::NVSDK_NGX_DLSS_QualitySetting_Ultra_Quality => DlssQuality::UltraQuality,
                _ => DlssQuality::Balanced,
            }).collect())
        }
    }
    
    /// Get optimal dimensions for DLSS rendering based on quality setting
    pub fn get_optimal_settings(&self, 
                               output_width: u32, 
                               output_height: u32, 
                               quality: DlssQuality) -> Result<DlssSettings> {
        if !self.initialized {
            return Err(DlssError::NotInitialized);
        }
        
        let mut render_width = 0;
        let mut render_height = 0;
        let mut max_render_width = 0;
        let mut max_render_height = 0;
        let mut min_render_width = 0;
        let mut min_render_height = 0;
        
        let result = unsafe {
            bindings::NVSDK_NGX_DLSS_GetOptimalSettings(
                output_width,
                output_height,
                quality.to_raw(),
                &mut render_width,
                &mut render_height,
                &mut max_render_width,
                &mut max_render_height,
                &mut min_render_width,
                &mut min_render_height,
            )
        };
        
        if result != bindings::NVSDK_NGX_Result_Success {
            return Err(DlssError::InvalidParameter);
        }
        
        Ok(DlssSettings {
            optimal_render_width: render_width,
            optimal_render_height: render_height,
            max_render_width,
            max_render_height, 
            min_render_width,
            min_render_height,
            output_width,
            output_height,
        })
    }
}

impl Drop for DlssInstance {
    fn drop(&mut self) {
        if self.initialized {
            unsafe {
                bindings::NVSDK_NGX_Shutdown();
            }
            self.initialized = false;
        }
    }
}

/// DLSS Optimal render settings for a given output resolution
#[derive(Debug, Clone, Copy)]
pub struct DlssSettings {
    pub optimal_render_width: u32,
    pub optimal_render_height: u32,
    pub max_render_width: u32,
    pub max_render_height: u32,
    pub min_render_width: u32,
    pub min_render_height: u32,
    pub output_width: u32,
    pub output_height: u32,
}

/// DLSS feature instance
pub struct DlssFeature {
    handle: bindings::NVSDK_NGX_Handle_t,
    parameters: bindings::NVSDK_NGX_Parameter_t,
}

impl DlssFeature {
    /// Create a new DLSS feature
    pub fn new(cmd_list: *mut c_void, 
              parameters: DlssParameters) -> Result<Self> {
        let mut ngx_params = ptr::null_mut();
        let result = unsafe { bindings::NVSDK_NGX_AllocateParameters(&mut ngx_params) };
        if result != bindings::NVSDK_NGX_Result_Success {
            return Err(DlssError::ParametersAllocationFailed);
        }
        
        // Set parameters
        unsafe {
            bindings::NVSDK_NGX_Parameter_SetI(ngx_params, 0 /*Width*/, parameters.output_width);
            bindings::NVSDK_NGX_Parameter_SetI(ngx_params, 1 /*Height*/, parameters.output_height);
            bindings::NVSDK_NGX_Parameter_SetI(ngx_params, 105 /*RenderWidth*/, parameters.render_width);
            bindings::NVSDK_NGX_Parameter_SetI(ngx_params, 106 /*RenderHeight*/, parameters.render_height);
            bindings::NVSDK_NGX_Parameter_SetI(ngx_params, 107 /*Quality*/, parameters.quality.to_raw());
            
            if let Some(sharpness) = parameters.sharpness {
                bindings::NVSDK_NGX_Parameter_SetF(ngx_params, 3 /*Sharpness*/, sharpness);
            }
        }
        
        let mut handle = ptr::null_mut();
        let result = unsafe {
            bindings::NVSDK_NGX_CreateFeature(
                cmd_list,
                bindings::NVSDK_NGX_Feature_DLSS,
                ngx_params,
                &mut handle,
            )
        };
        
        if result != bindings::NVSDK_NGX_Result_Success {
            unsafe { bindings::NVSDK_NGX_DestroyParameters(ngx_params) };
            return Err(DlssError::FeatureCreationFailed);
        }
        
        Ok(DlssFeature {
            handle,
            parameters: ngx_params,
        })
    }
    
    /// Upscale an image
    pub fn upscale(&self, 
                  cmd_list: *mut c_void,
                  input_color: *mut c_void,
                  output_color: *mut c_void,
                  motion_vectors: Option<*mut c_void>,
                  depth: Option<*mut c_void>,
                  exposure: Option<*mut c_void>,
                  jitter_x: Option<f32>,
                  jitter_y: Option<f32>,
                  sharpness: Option<f32>) -> Result<()> {
        unsafe {
            // Set input/output resources
            bindings::NVSDK_NGX_Parameter_SetVoidPointer(
                self.parameters, 
                101 /*DLSS_Input_Color*/, 
                input_color as *mut _);
                
            bindings::NVSDK_NGX_Parameter_SetVoidPointer(
                self.parameters, 
                104 /*DLSS_Output_Color*/, 
                output_color as *mut _);
                
            // Optional parameters
            if let Some(mv) = motion_vectors {
                bindings::NVSDK_NGX_Parameter_SetVoidPointer(
                    self.parameters, 
                    103 /*DLSS_Input_MotionVectors*/, 
                    mv as *mut _);
            }
            
            if let Some(d) = depth {
                bindings::NVSDK_NGX_Parameter_SetVoidPointer(
                    self.parameters, 
                    102 /*DLSS_Input_Depth*/, 
                    d as *mut _);
            }
            
            if let Some(s) = sharpness {
                bindings::NVSDK_NGX_Parameter_SetF(self.parameters, 3 /*Sharpness*/, s);
            }
            
            // Run DLSS
            let result = bindings::NVSDK_NGX_EvaluateFeature(
                cmd_list,
                self.handle,
                self.parameters,
            );
            
            if result != bindings::NVSDK_NGX_Result_Success {
                return Err(DlssError::EvaluationFailed);
            }
            
            Ok(())
        }
    }
}

impl Drop for DlssFeature {
    fn drop(&mut self) {
        unsafe {
            if !self.handle.is_null() {
                bindings::NVSDK_NGX_Release(self.handle);
                self.handle = ptr::null_mut();
            }
            
            if !self.parameters.is_null() {
                bindings::NVSDK_NGX_DestroyParameters(self.parameters);
                self.parameters = ptr::null_mut();
            }
        }
    }
}

/// Parameters for creating a DLSS feature
#[derive(Debug, Clone)]
pub struct DlssParameters {
    pub render_width: u32,
    pub render_height: u32,
    pub output_width: u32,
    pub output_height: u32,
    pub quality: DlssQuality,
    pub sharpness: Option<f32>,
}

/// Check if the system has DLSS capabilities
pub fn has_dlss_capability(device: *mut c_void) -> bool {
    let mut num_qualities = 0;
    unsafe {
        let result = bindings::NVSDK_NGX_DLSS_GetCapability(
            device,
            ptr::null_mut(),
            &mut num_qualities,
        );
        
        result == bindings::NVSDK_NGX_Result_Success && num_qualities > 0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_quality_settings() {
        assert_eq!(DlssQuality::UltraPerformance.scale_factor(), 0.33);
        assert_eq!(DlssQuality::MaxPerformance.scale_factor(), 0.5);
        assert_eq!(DlssQuality::Balanced.scale_factor(), 0.58);
        assert_eq!(DlssQuality::MaxQuality.scale_factor(), 0.67);
        assert_eq!(DlssQuality::UltraQuality.scale_factor(), 0.77);
    }
} 